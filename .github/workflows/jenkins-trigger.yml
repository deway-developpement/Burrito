name: Trigger Jenkins Build

on:
  push:
    branches: ["production"]
  workflow_dispatch:

jobs:
  trigger-jenkins:
    runs-on: ubuntu-latest
    steps:
      - name: Trigger Jenkins job and wait for result
        env:
          JENKINS_URL: ${{ secrets.JENKINS_URL }}
          JENKINS_USER: ${{ secrets.JENKINS_USER }}
          JENKINS_API_TOKEN: ${{ secrets.JENKINS_API_TOKEN }}
          JENKINS_JOB: ${{ secrets.JENKINS_JOB }}
          # Optional: URL query string for parameterized builds, e.g. "BRANCH=main&ENV=prod"
          JENKINS_PARAMS: ${{ secrets.JENKINS_PARAMS }}
        run: |
          set -euo pipefail

          if [ -z "${JENKINS_URL}" ] || [ -z "${JENKINS_USER}" ] || [ -z "${JENKINS_API_TOKEN}" ] || [ -z "${JENKINS_JOB}" ]; then
            echo "One or more required Jenkins secrets are missing (JENKINS_URL, JENKINS_USER, JENKINS_API_TOKEN, JENKINS_JOB)." >&2
            exit 1
          fi

          CRUMB_HEADER=$(curl -sSf --user "${JENKINS_USER}:${JENKINS_API_TOKEN}" \
            "${JENKINS_URL}/crumbIssuer/api/xml?xpath=concat(//crumbRequestField,\":\",//crumb)" || true)

          if [ -n "${CRUMB_HEADER}" ]; then
            echo "Crumb retrieved from Jenkins."
          else
            echo "No crumb header returned; proceeding without crumb."
          fi

          echo "Triggering Jenkins job ${JENKINS_JOB}..."
          BUILD_ENDPOINT="buildWithParameters"
          PARAMS="K8S_NAMESPACE=evaluation-system"
          JOB_PATH="/job/${JENKINS_JOB}/${BUILD_ENDPOINT}"
          BUILD_URL_TRIGGER="${JENKINS_URL}${JOB_PATH}?${PARAMS}"
          if [ -n "${JENKINS_PARAMS:-}" ]; then
            BUILD_ENDPOINT="buildWithParameters"
            JOB_PATH="/job/${JENKINS_JOB}/${BUILD_ENDPOINT}"
            BUILD_URL_TRIGGER="${JENKINS_URL}${JOB_PATH}?${JENKINS_PARAMS}"
          fi

          echo "Trigger URL path: ${JOB_PATH}"
          echo "Using endpoint: ${BUILD_ENDPOINT}"

          TRIGGER_RESPONSE=$(mktemp)
          TRIGGER_HEADERS=$(curl -isS -X POST --user "${JENKINS_USER}:${JENKINS_API_TOKEN}" \
            ${CRUMB_HEADER:+-H "$CRUMB_HEADER"} \
            -o /dev/null -D - -w "\n%{http_code}" \
            "${BUILD_URL_TRIGGER}" | tee "${TRIGGER_RESPONSE}")

          STATUS_CODE=$(tail -n1 "${TRIGGER_RESPONSE}")
          TRIGGER_HEADERS=$(printf "%s" "${TRIGGER_HEADERS}" | sed '$d') # drop status code line from headers

          if [ "${STATUS_CODE}" != "201" ] && [ "${STATUS_CODE}" != "302" ]; then
            echo "Failed to trigger Jenkins job. HTTP status: ${STATUS_CODE}"
            echo "Headers:"
            echo "${TRIGGER_HEADERS}"
            echo "URL called: ${BUILD_URL_TRIGGER}"
            exit 1
          fi

          QUEUE_URL=$(printf "%s" "${TRIGGER_HEADERS}" | awk '/[Ll]ocation:/{print $2}' | tr -d '\r')

          if [ -z "${QUEUE_URL:-}" ]; then
            echo "Failed to retrieve queue location from Jenkins response. Headers were:"
            echo "${TRIGGER_HEADERS}"
            exit 1
          fi

          echo "Build queued at ${QUEUE_URL}"

          echo "Waiting for build to start..."
          BUILD_URL=""
          for _ in $(seq 1 60); do
            QUEUE_STATE=$(curl -sSf --user "${JENKINS_USER}:${JENKINS_API_TOKEN}" "${QUEUE_URL}api/json")
            BUILD_URL=$(echo "${QUEUE_STATE}" | jq -r '.executable.url // empty')
            if [ -n "${BUILD_URL}" ]; then
              break
            fi
            if echo "${QUEUE_STATE}" | jq -e '.cancelled == true' >/dev/null; then
              echo "Jenkins queue item was cancelled."
              exit 1
            fi
            sleep 5
          done

          if [ -z "${BUILD_URL}" ]; then
            echo "Timed out waiting for the Jenkins build to start."
            exit 1
          fi

          echo "Build started at ${BUILD_URL}"

          echo "Waiting for build to finish..."
          RESULT=""
          for _ in $(seq 1 120); do
            BUILD_STATE=$(curl -sSf --user "${JENKINS_USER}:${JENKINS_API_TOKEN}" "${BUILD_URL}api/json")
            BUILDING=$(echo "${BUILD_STATE}" | jq -r '.building')
            RESULT=$(echo "${BUILD_STATE}" | jq -r '.result // empty')
            if [ "${BUILDING}" = "false" ]; then
              break
            fi
            sleep 5
          done

          if [ -z "${RESULT}" ]; then
            echo "Timed out waiting for Jenkins build to complete."
            exit 1
          fi

          echo "Jenkins build finished with result: ${RESULT}"

          if [ "${RESULT}" != "SUCCESS" ]; then
            exit 1
          fi
